#### **1. Breve História do UNIX**

O UNIX é uma vasta família de sistemas operacionais cujas raízes remontam ao projeto MULTICS do final dos anos 60. Após o fracasso comercial do MULTICS, pesquisadores da Bell Labs desenvolveram o UNICS, que foi posteriormente reescrito na linguagem C por Dennis Ritchie. Essa reescrita em uma linguagem de alto nível facilitou a portabilidade do sistema para múltiplas arquiteturas, um fator chave para sua popularização.

A Bell Labs distribuiu o código para universidades, o que levou ao desenvolvimento de variantes importantes como o **UNIX BSD** (que introduziu a pilha TCP/IP para comunicação em rede). A AT&T, por sua vez, lançou versões comerciais de sucesso como o **System V**. O **Linux**, criado por Linus Torvalds em 1991, é um kernel que, combinado com o software do projeto GNU, forma as distribuições Linux que conhecemos hoje.

#### **2. Criação de Processos: O Paradigma `fork()` e `exec()`**

No UNIX, a criação de processos é um processo de duas etapas:

1. **Clonagem com `fork()`**: A principal maneira de criar um novo processo em C é usando a chamada de sistema `fork()`. Essa função cria um processo filho que é um clone quase idêntico do processo pai, copiando a maior parte de sua tabela de processos. Ambos os processos (pai e filho) continuam a execução a partir do ponto imediatamente após a chamada `fork()`. A diferenciação entre eles é feita pelo valor de retorno da função:

    - No **processo pai**, `fork()` retorna o PID (Process ID) do filho recém-criado.
    - No **processo filho**, `fork()` retorna `0`.

2. **Carregamento de um Novo Programa com `exec()`**: Como o `fork()` apenas cria uma cópia, para executar um programa diferente, o processo filho geralmente chama uma das funções da família `exec` (como `execvp`). A chamada `exec` substitui a imagem do processo atual por um novo programa. Se for bem-sucedida, a função `exec` **nunca retorna**, pois o processo passa a executar o novo código desde o início.

#### **3. Comunicação via Sinais**

Sinais são um mecanismo fundamental do UNIX para notificar um processo sobre a ocorrência de um evento.

- **Funcionamento**: Ao receber um sinal, um processo interrompe sua execução normal e chama uma função específica, conhecida como "handler", para tratar o evento. É possível configurar um handler usando a chamada `sigaction`.
- **Envio de Sinais**: Sinais podem ser enviados de um terminal usando o comando `kill` (ex: `kill -SIGUSR1 <pid>`) ou de dentro de um programa C usando a função `kill(pid, signal_number)`.
- **Sinais Comuns**:
    - `SIGTERM` e `SIGKILL`: Usados para terminar processos. `SIGTERM` pode ser ignorado, mas `SIGKILL` não.
    - `SIGUSR1` e `SIGUSR2`: Sinais definidos para uso livre pelo programador.
    - `SIGSEGV`: Indica uma falha de segmentação (erro de acesso à memória).

#### **4. Término de Processos e o Estado Zumbi**

Um processo pode terminar de duas formas:

1. **Voluntariamente**: Retornando da função `main` ou chamando `exit()`. Por convenção, `exit(0)` indica sucesso e `exit(1)` indica erro.
2. **Involuntariamente**: Ao receber um sinal que causa seu término, como `SIGTERM` ou `SIGKILL`.

##### **Aguardando o Término e Processos Zumbis**

- **Aguardando com `wait()`**: Um processo pai pode (e deve) aguardar o término de um processo filho usando a chamada de sistema `wait()`. Se o filho ainda não terminou, a chamada `wait()` bloqueia o pai até que o filho termine.
- **Processos Zumbis**: Quando um processo filho termina, ele entra em um estado "zumbi". Neste estado, o processo já liberou todos os seus recursos, mas sua entrada na tabela de processos do sistema é mantida para que o processo pai possa ler seu status de saída (através da chamada `wait()`). O processo zumbi só é completamente removido do sistema depois que o pai "coleta" essa informação chamando `wait()`.